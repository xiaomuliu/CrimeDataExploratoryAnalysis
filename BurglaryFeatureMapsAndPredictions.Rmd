---
title: "BurglaryFeatureMapsAndPredictions"
date: "September 29, 2015"
output: html_document
---

The regular grid is made by setting up a 180 $\times$ 240 grid then constraining it by keeping those inside the city boundary, in which 17472 grids are included (spatial resolution: 637 ft $\times$ 576 ft/pixel cell).

```{r regular-grid, echo=FALSE, message=FALSE, warning=FALSE,cache=TRUE}
library(sp)
library(rgeos)
library(rgdal)
library(raster)

Path.GIS <- "/Users/xiaomuliu/CrimeProject/SpatioTemporalModeling/GISData/"
Path.city <- paste0(Path.GIS,"City_Boundary")
city.shp <- readOGR(Path.city,"City_Boundary") 
ncell.x <- 180
ncell.y <- 240
X_range <- city.shp@bbox[1,]
Y_range <- city.shp@bbox[2,]
grd.full <- expand.grid(list(X_COORD=seq(X_range[1],X_range[2],length.out=ncell.x),
                             Y_COORD=seq(Y_range[1],Y_range[2],length.out=ncell.y)))
coordinates(grd.full) = ~X_COORD+Y_COORD # convert to SpatialPoints

prj <- paste("+proj=tmerc +lat_0=36.66666666666666 +lon_0=-88.33333333333333 +k=0.9999749999999999",
             "+x_0=300000 +y_0=0 +datum=NAD83 +units=us-ft +no_defs +ellps=GRS80 +towgs84=0,0,0")
proj4string(grd.full) <- prj

# rasterize the city spatial polygon to get a grid template
grd.full <- SpatialPixels(grd.full)
r <- raster(ncol=grd.full@grid@cells.dim[1],nrow=grd.full@grid@cells.dim[2],
            xmn=grd.full@bbox[1,1],xmx=grd.full@bbox[1,2],ymn=grd.full@bbox[2,1],ymx=grd.full@bbox[2,2],crs=CRS(prj))

city.raster <- rasterize(city.shp,r,0)
city.df_full <- as.data.frame(city.raster,xy=TRUE)
city.df_full <- city.df_full[,1:2]
names(city.df_full) <- c("X_COORD","Y_COORD")
RegGrd.full <- city.df_full

coordinates(city.df_full) <- c("X_COORD", "Y_COORD") 
proj4string(city.df_full) <- prj
BoundedOverFullGrd <- over(city.df_full, city.shp)
isInCity <- !is.na(BoundedOverFullGrd$OBJECTID)
RegGrd <- RegGrd.full[isInCity,]
```

```{r load-shapefiles, echo=FALSE, message=FALSE, warning=FALSE,cache=TRUE}
Path.street_line <- paste0(Path.GIS,"Street_Center_Line")
Path.major_street <- paste0(Path.GIS,"Major_Streets")
Path.cpd_station <- paste0(Path.GIS,"police_stations_poly")
Path.school <- paste0(Path.GIS,"School_Grounds")
Path.park <- paste0(Path.GIS,"Parks_Aug2012")
Path.hospital <- paste0(Path.GIS,"Hospitals")
Path.library <- paste0(Path.GIS,"Libraries")
Path.CTA_stop <-paste0(Path.GIS,"CTA_BusStops")
Path.CTA_route <- paste0(Path.GIS,"CTA_Routes")
Path.CTA_rail <- paste0(Path.GIS,"CTA_RailLines")
Path.building <- paste0(Path.GIS,"Buildings")

street_line.shp <- readOGR(Path.street_line,"Transportation")
major_street.shp <- readOGR(Path.major_street,"Major_Streets")
cpd_station.shp <- readOGR(Path.cpd_station,"police_stations")
school.shp <- readOGR(Path.school,"School_Grounds")
park.shp <- readOGR(Path.park,"Parks_Aug2012")
hospital.shp <- readOGR(Path.hospital,"Hospitals")
library.shp <- readOGR(Path.library,"Libraries")
CTA_stop.shp <- readOGR(Path.CTA_stop,"CTA_BusStops")
CTA_stop.shp <- spTransform(CTA_stop.shp, CRSobj=prj)
CTA_route.shp <- readOGR(Path.CTA_route,"CTA_Routes")
CTA_rail.shp <- readOGR(Path.CTA_rail,"CTA_RailLines")
building.shp <- readOGR(Path.building,"Buildings")  # ~3 GB file!
building.spdf <- building.shp
building.spdf@data <- subset(building.spdf@data,select=c("BLDG_ID","BLDG_STATU","STORIES","NO_OF_UNIT","NO_STORIES",
                                                         "NON_STANDA","YEAR_BUILT","BLDG_SQ_FO","BLDG_CONDI","VACANCY_ST",
                                                         "X_COORD","Y_COORD","SHAPE_AREA","SHAPE_LEN"))
# load("buildingShp.RData")

# rename the attribute "NO_STORIES" as "UG_STORIES" (number of stories below ground) to make it less misleading
names(building.spdf@data)[names(building.spdf@data)=="NO_STORIES"] <- "UG_STORIES"
#remove "non-standard" building: 8500, CTAPLAT, MONUMNET, OTHER, keep only residential garage and NA's
building.spdf <- subset(building.spdf, NON_STANDA=="RSGARAGE" | is.na(NON_STANDA))
# remove 95 "proposed", 1 "demolished" and 1 "NA" in BLDG_STATU entries
building.spdf <- subset(building.spdf,BLDG_STATU=="ACTIVE",select=-c(BLDG_STATU))
#remove three entries where x,y coordinates are zeros
building.spdf <- subset(building.spdf, X_COORD!=0 & Y_COORD!=0)
```
Compute time-invariant (Spatial) features:
For each pixel, the spatial features are extracted from a region that is formed by extending the coordinate of the centroid of each pixel cell by 330 feet in both X and Y directions (roughly in line with the Chicago city block length (660 ft)). Note: the resolution of the binned crime images and the resolution of patches for extracting features do not have to be the same. Because both raw data are recorded on a extremely high resolution geospatial grid record. This enables us to calculate feature values without having to rasterize them into images of the same resolution of the binned crime images. 
```{r spatial-features, echo=FALSE, message=FALSE, warning=FALSE,cache=TRUE}
source("POIFunction.R")

extension.x <- 330
extension.y <- 330
extension <- c(extension.x,extension.y)

RegGrd <- StreetDen(RegGrd,street_line.shp,extension,Attr="StrDen",prj=prj)
RegGrd <- Grd2POIdist(RegGrd,major_street.shp,"Dist2Street",prj=prj)
RegGrd <- Grd2POIdist(RegGrd,cpd_station.shp,"Dist2CPDstation",prj=prj)
RegGrd <- Grd2POIdist(RegGrd,school.shp,"Dist2School",prj=prj)
RegGrd <- Grd2POIdist(RegGrd,park.shp,"Dist2Park",prj=prj)
RegGrd <- Grd2POIdist(RegGrd,hospital.shp,"Dist2Hospital",prj=prj)
RegGrd <- Grd2POIdist(RegGrd,library.shp,"Dist2Library",prj=prj)
RegGrd <- Grd2POIdist(RegGrd,CTA_stop.shp,"Dist2BusStop",prj=prj)
RegGrd <- Grd2POIdist(RegGrd,CTA_route.shp,"Dist2CTAroute",prj=prj)
RegGrd <- Grd2POIdist(RegGrd,CTA_rail.shp,"Dist2CTArail",prj=prj)
RegGrd <- BuildingDen(RegGrd,subset(building.spdf,is.na(NON_STANDA)),extension,Attr="BldgDen")
RegGrd <- BuildingDen(RegGrd,subset(building.spdf,NON_STANDA=="RSGARAGE"),extension,Attr="GarageDen")
RegGrd <- BuildingType(RegGrd,subset(building.spdf,is.na(NON_STANDA)),extension,Attr="AvgStories",
                       BldgType="STORIES",fun=mean,na.rm=TRUE)
RegGrd <- BuildingType(RegGrd,subset(building.spdf,is.na(NON_STANDA)),extension,Attr="AvgUnits",
                       BldgType="NO_OF_UNIT",fun=mean,na.rm=TRUE)
```

```{r train-test-partition, echo=FALSE, message=FALSE, warning=FALSE, cache=TRUE}
# startDate.train <- as.Date("2013-01-01")
# endDate.train <- as.Date("2013-12-31")
# dateSeq.train <- seq.Date(startDate.train,endDate.train,by=1)
startDate.test <- as.Date("2014-01-01")
endDate.test <- as.Date("2014-12-31")
dateSeq.test <- seq.Date(startDate.test,endDate.test,by=1)

Ndays.train <- 365
Ndays.test <- length(dateSeq.test)
```

```{r load-weatherdata, echo=FALSE, message=FALSE, warning=FALSE, cache=TRUE}
source("WeatherDataFunctions.R")
WeatherFilePath <- "/Users/xiaomuliu/CrimeProject/SpatioTemporalModeling/ExploratoryAnalysis/WeatherData/"
Weather.startDate="01/01/2001"
Weather.endDate="12/31/2014"
filename.daily <- paste(WeatherFilePath,'WeatherData_Daily_',as.character(as.Date(Weather.startDate, "%m/%d/%Y")),
                        '_',as.character(as.Date(Weather.endDate, "%m/%d/%Y")),'.csv',sep='')
WeatherData.daily <- read.csv(filename.daily)
WeatherData.daily$Date <- as.Date(WeatherData.daily$Date)
```
The "near-repeat-effect" feature is calculated by doing a 3D convolutiong with the kernel specified below:
$$ K(x,y,t) = \frac{1}{2\pi \sigma^2}\exp(-\frac{(x+y)^2}{2 \sigma^2}) \cdot \exp(-\lambda t)$$
where $\sigma=2$ (2 grid cells of which the size is 637 ft $\times$ 576 ft), $\lambda=0.1$ in these experiments.
```{r kernel-specifications, echo=FALSE, message=FALSE, warning=FALSE,cache=TRUE}
# For the time dimesion, instead of using convolution, 
# we can simplify the process by just performing the dot multiplication of *rev(kernel.t)* 
# and the preceding *window.t* spatial smoothed data layers. 
# Because only the last day will be used as the feature for the next day

# Set up kernels
window.x <- 5  # unit: raster cell size
window.y <- 5
window.t <- 14 # unit: day

kernel.Xdim <- 5
kernel.Ydim <- 5
kernel.Tdim <- 14

kernel.Xgrd <- seq(-window.x,window.x,length.out=kernel.Xdim)
kernel.Ygrd <- seq(-window.y,window.y,length.out=kernel.Ydim)
kernel.Tgrd <- seq(0,window.t,length.out=kernel.Tdim)

sigma <- 2
lambda <- 0.1
kernel.x <- 1/(sqrt(2*pi)*sigma)*exp(-kernel.Xgrd^2/(2*sigma^2))
kernel.y <- 1/(sqrt(2*pi)*sigma)*exp(-kernel.Ygrd^2/(2*sigma^2))
kernel.t <- exp(-lambda*kernel.Tgrd)
```

```{r load-crimedata, echo=FALSE, message=FALSE, warning=FALSE, cache=TRUE}
load("MatchedBurglaryData_portal.RData")
```

The features are consisted of the following: 1. time-related, 2. weather, 3. space-related 4. historic burglary rate

Since we rasterized the point data to a dense grid, we get one incident in a bin most of the times. However, occasionally there are two or more incidents happening within a bin at our resolution. So we did two experiments: categorizing our target class into three classes where 0 indicates no incident, 1 indicates one incident, 2 indicates two or more incidents; categorizing the target class into two classes where 0 indicates no incident, 1 indicates incident present.
```{r feature-maps-setup, echo=FALSE, message=FALSE, warning=FALSE, cache=TRUE}
source("ConvFunction.R")

VarName.time <- c("DAY","MONTH","YEAR","DOW","HOLIDAY")
VarName.weather <- names(subset(WeatherData.daily,select=-Date))
VarName.space <- c("StrDen","Dist2Street","Dist2CPDstation","Dist2School","Dist2Park","Dist2Hospital","Dist2Library",
                  "Dist2BusStop","Dist2CTAroute","Dist2CTArail","BldgDen","GarageDen","AvgStories","AvgUnits")
VarName.crime <- c("NearbyEffect","LongtermEffect")
VarName <- c(VarName.time,VarName.weather,VarName.space,VarName.crime)
period.long <- 365
Ngrids <- nrow(RegGrd) 
FeatureVec.train <- matrix(NA,nrow=Ndays.train*Ngrids,ncol=length(VarName))
FeatureVec.train <- as.data.frame(FeatureVec.train)
names(FeatureVec.train) <- VarName
Label3c.train <- factor(rep(0,nrow(FeatureVec.train)),levels=0:2)

FeatureVec.train$DOW <- factor(FeatureVec.train$DOW, levels=c("Sun","Mon","Tue","Wed","Thu","Fri","Sat"))
FeatureVec.train$HOLIDAY <- factor(FeatureVec.train$HOLIDAY,levels=levels(BurglaryData$HOLIDAY))
FeatureVec.train$MONTH <- factor(FeatureVec.train$MONTH,levels=1:12)

FeatureVec.test <- matrix(NA,nrow=Ndays.test*Ngrids,ncol=length(VarName))
FeatureVec.test <- as.data.frame(FeatureVec.test)
names(FeatureVec.test) <- VarName
Label3c.test <- factor(rep(0,nrow(FeatureVec.test)),levels=0:2)
Label2c.test <- factor(rep(0,nrow(FeatureVec.test)),levels=c(0,1))
TestDataLabel <- factor(rep(0,nrow(FeatureVec.test)),levels=c(0,1))

FeatureVec.test$DOW <- factor(FeatureVec.test$DOW, levels=c("Sun","Mon","Tue","Wed","Thu","Fri","Sat"))
FeatureVec.test$HOLIDAY <- factor(FeatureVec.test$HOLIDAY,levels=levels(BurglaryData$HOLIDAY))
FeatureVec.test$MONTH <- factor(FeatureVec.test$MONTH,levels=1:12)

Pred.test_lda <- data.frame(class=rep(0,Ndays.test*Ngrids),prob=rep(0,Ndays.test*Ngrids))
Pred.test_logit <- data.frame(class=rep(0,Ndays.test*Ngrids),prob=rep(0,Ndays.test*Ngrids))

minmaxScale <- function(x,center=min(x),scale=max(x)-min(x)){
  x <- (x-center)/scale
  return(x)
}

```

```{r one-day-ahead-prediction, echo=FALSE, message=FALSE, warning=FALSE, cache=TRUE}
library(MASS)

for (i in 1:Ndays.test){
  d.test <- dateSeq.test[i]
  
  # Add *window.t* days as the buffer so that the kernel smoothed feature would be able to comupted 
  BurglaryData.train <- subset(BurglaryData,DATEOCC>=d.test-window.t-Ndays.train & DATEOCC<=d.test-1)
  BurglaryData.test <- subset(BurglaryData,DATEOCC>=d.test-window.t & DATEOCC<=d.test)
  
  WeatherData.train <- subset(WeatherData.daily,Date>=d.test-window.t-Ndays.train & Date<=d.test-1)
  WeatherData.test <- subset(WeatherData.daily,Date==d.test)
  
  ## Training features
  dateSeq.train <- seq.Date(d.test-Ndays.train,d.test-1,by=1)
  for (j in 1:Ndays.train){  
    d.train <- dateSeq.train[j]
    
    # Temporal variables
    BurglaryData.time <- subset(BurglaryData.train, DATEOCC==d.train,select=VarName.time)
    FeatureVec.train[((j-1)*Ngrids+1):(j*Ngrids),VarName.time] <- BurglaryData.time[rep(1,Ngrids),]
    
    # Weather variables
    WeatherData.day <- subset(WeatherData.train,Date==d.train,select=-Date)
    FeatureVec.train[((j-1)*Ngrids+1):(j*Ngrids),VarName.weather] <- WeatherData.day[rep(1,Ngrids),]
    
    # Spatial variables
    FeatureVec.train[((j-1)*Ngrids+1):(j*Ngrids),VarName.space] <- RegGrd[,VarName.space] 
    
    # Historic burglary variable
    KS <- KernSmNearbyCrime(BurglaryData.train,d.train,RegGrd.full,r,window.t,kernel.x,kernel.y,kernel.t,isInCity,prj)
    BurglaryHistPts.long <- subset(BurglaryData,DATEOCC>=d.train-period.long & DATEOCC<=d.train-1,select=c("X_COORD","Y_COORD","INC_CNT"))  
    KDE.long <- SpatialKernSmCrime(BurglaryHistPts.long,RegGrd.full,r,kernel.x,kernel.y,isInCity,prj)
    FeatureVec.train[((j-1)*Ngrids+1):(j*Ngrids),VarName.crime] <- cbind(KS$KernSm.df_inPoly$KS_VAL, KDE.long$KernSm.df_inPoly$KS_VAL)
    
    # assign labels according to the burglary counts
    BurglaryData.day <- subset(BurglaryData.train, DATEOCC==d.train, select=c("X_COORD","Y_COORD","INC_CNT"))
    BurglaryRaster <- rasterize(BurglaryData.day[,c("X_COORD","Y_COORD")], r, BurglaryData.day$INC_CNT, fun=sum)
    BurglaryRaster.df_inCity <- as.data.frame(BurglaryRaster)[isInCity,]
    BurglaryRaster.df_inCity[is.na(BurglaryRaster.df_inCity)] <- 0
    
    idx.lv1 <- BurglaryRaster.df_inCity==1
    idx.lv2 <- BurglaryRaster.df_inCity>1
    level <- rep(0,Ngrids)
    level[idx.lv1] <- 1
    level[idx.lv2] <- 2
    Label3c.train[((j-1)*Ngrids+1):(j*Ngrids)] <- level 
  }
  Label3c.train <- as.factor(Label3c.train)
  # Two-class case
  Label2c.train <- as.factor(as.numeric(Label3c.train!=0))
  
  # scale training features
  FeatureVec.train_scale <- cbind(FeatureVec.train[,VarName.time],apply(FeatureVec.train[,c(VarName.weather,VarName.space,VarName.crime)],2,minmaxScale))
  TrainData <- cbind(subset(FeatureVec.train_scale,select=-c(DAY,YEAR)),Label3c.train,Label2c.train)
  
  ## Test features 
  # Temporal variables
  BurglaryData.time <- subset(BurglaryData.test, DATEOCC==d.test,select=VarName.time)
  FeatureVec.test[((i-1)*Ngrids+1):(i*Ngrids),VarName.time] <- BurglaryData.time[rep(1,Ngrids),]
  # Weather variables
  WeatherData.day <- subset(WeatherData.test,Date==d.test,select=-Date)
  FeatureVec.test[((i-1)*Ngrids+1):(i*Ngrids),VarName.weather] <- WeatherData.day[rep(1,Ngrids),]
  
  # Spatial variables
  FeatureVec.test[((i-1)*Ngrids+1):(i*Ngrids),VarName.space] <- RegGrd[,VarName.space] 
  
  # Kernel-smoothed-neighboring-incident variable
  KS <- KernSmNearbyCrime(BurglaryData.test,d.test,RegGrd.full,r,window.t,kernel.x,kernel.y,kernel.t,isInCity,prj)
  BurglaryHistPts.long <- subset(BurglaryData,DATEOCC>=d.test-period.long & DATEOCC<=d.test-1,select=c("X_COORD","Y_COORD","INC_CNT"))  
  KDE.long <- SpatialKernSmCrime(BurglaryHistPts.long,RegGrd.full,r,kernel.x,kernel.y,isInCity,prj) 
  FeatureVec.test[((i-1)*Ngrids+1):(i*Ngrids),VarName.crime] <- cbind(KS$KernSm.df_inPoly$KS_VAL, KDE.long$KernSm.df_inPoly$KS_VAL)
  
  # assign labels according to the burglary counts
  BurglaryData.day <- subset(BurglaryData.test, DATEOCC==d.test, select=c("X_COORD","Y_COORD","INC_CNT"))
  BurglaryRaster <- rasterize(BurglaryData.day[,c("X_COORD","Y_COORD")], r, BurglaryData.day$INC_CNT, fun=sum)
  BurglaryRaster.df_inCity <- as.data.frame(BurglaryRaster)[isInCity,]
  BurglaryRaster.df_inCity[is.na(BurglaryRaster.df_inCity)] <- 0
  
  idx.lv1 <- BurglaryRaster.df_inCity==1
  idx.lv2 <- BurglaryRaster.df_inCity>1
  level <- rep(0,Ngrids)
  level[idx.lv1] <- 1
  level[idx.lv2] <- 2
  Label3c.test[((i-1)*Ngrids+1):(i*Ngrids)] <- as.factor(level)
  Label2c.test[((i-1)*Ngrids+1):(i*Ngrids)] <- as.factor(as.numeric(level!=0))
  
  # scale test features
  ctr <- apply(FeatureVec.train[,c(VarName.weather,VarName.space,VarName.crime)],2,min)
  sc <- apply(FeatureVec.train[,c(VarName.weather,VarName.space,VarName.crime)],2,max)- apply(FeatureVec.train[,c(VarName.weather,VarName.space,VarName.crime)],2,min)
  FeatureVec.test_scale <- cbind(FeatureVec.test[((i-1)*Ngrids+1):(i*Ngrids),VarName.time],scale(FeatureVec.test[((i-1)*Ngrids+1):(i*Ngrids),c(VarName.weather,VarName.space,VarName.crime)],center=ctr,scale=sc))
  TestData <- cbind(subset(FeatureVec.test_scale,select=-c(DAY,YEAR)),Label3c.test=Label3c.test[((i-1)*Ngrids+1):(i*Ngrids)],Label2c.test=Label2c.test[((i-1)*Ngrids+1):(i*Ngrids)])
  
  # Subset Training Data by randomly down-sampling class 0 instances
  Class0.train <- subset(subset(TrainData,select=-c(Label3c.train)),Label2c.train==0)
  Class1.train <- subset(subset(TrainData,select=-c(Label3c.train)),Label2c.train==1)
  SubSample <- sample(1:nrow(Class0.train),size=nrow(Class1.train))
  Class0.train_sub <- Class0.train[SubSample,]
  TrainData.sub <- rbind(Class0.train_sub,Class1.train) 
  
  Class0.test <- subset(subset(TestData,select=-c(Label3c.test)),Label2c.test==0)
  Class1.test <- subset(subset(TestData,select=-c(Label3c.test)),Label2c.test==1)
  TestData.sub <- rbind(Class0.test,Class1.test) 
  
  #LDA
  Model.lda <- lda(Label2c.train~.,data=TrainData.sub)
  Pred.lda <- predict(Model.lda,TestData.sub)
  Pred.test_lda$class[((i-1)*Ngrids+1):(i*Ngrids)] <- Pred.lda$class
  Pred.test_lda$prob[((i-1)*Ngrids+1):(i*Ngrids)] <- Pred.lda$posterior[,2]

  # logistic regression
  Model.logit <- glm(Label2c.train~.,family=binomial(link="logit"), data=TrainData.sub)
  Pred.logit <- predict(Model.logit,TestData.sub,type="response")
  Pred.test_logit$class[((i-1)*Ngrids+1):(i*Ngrids)] <- ifelse(Pred.logit>=0.5, 1, 0)
  Pred.test_logit$prob[((i-1)*Ngrids+1):(i*Ngrids)] <- Pred.logit
  
  TestDataLabel[((i-1)*Ngrids+1):(i*Ngrids)] <- TestData.sub$Label2c.test
}

```

```{r hot-spot-2c, echo=FALSE, message=FALSE, warning=FALSE, cache=TRUE}
period.long <- 365
period.short1 <- 7
period.short2 <- 14

HotSpot.test <- data.frame(Long=rep(0,Ngrids*Ndays.test),Short1=rep(0,Ngrids*Ndays.test),Short2=rep(0,Ngrids*Ndays.test),Label3c.test,Label2c.test)

for (i in 1:Ndays.test){
  d <- dateSeq.test[i]
  
  BurglaryHistPts.long <- subset(BurglaryData,DATEOCC>=d-period.long & DATEOCC<=d-1,select=c("X_COORD","Y_COORD","INC_CNT"))
  BurglaryHistPts.short1 <- subset(BurglaryData,DATEOCC>=d-period.short1 & DATEOCC<=d-1,select=c("X_COORD","Y_COORD","INC_CNT"))
  BurglaryHistPts.short2 <- subset(BurglaryData,DATEOCC>=d-period.short2 & DATEOCC<=d-1,select=c("X_COORD","Y_COORD","INC_CNT"))
  
  KDE.long <- SpatialKernSmCrime(BurglaryHistPts.long,RegGrd.full,r,kernel.x,kernel.y,isInCity,prj)
  KDE.long_df_inCity <- KDE.long$KernSm.df_inPoly
  # scale to probability values ([0,1]) for each pixel
  KDE.long_df_inCity$KS_VAL <- minmaxScale(KDE.long_df_inCity$KS_VAL) 
 
  KDE.short1 <- SpatialKernSmCrime(BurglaryHistPts.short1,RegGrd.full,r,kernel.x,kernel.y,isInCity,prj)
  KDE.short1_df_inCity <- KDE.short1$KernSm.df_inPoly
  # scale to probability values ([0,1]) for each pixel
  KDE.short1_df_inCity$KS_VAL <- minmaxScale(KDE.short1_df_inCity$KS_VAL) 
  
  KDE.short2 <- SpatialKernSmCrime(BurglaryHistPts.short2,RegGrd.full,r,kernel.x,kernel.y,isInCity,prj)
  KDE.short2_df_inCity <- KDE.short2$KernSm.df_inPoly
  # scale to probability values ([0,1]) for each pixel
  KDE.short2_df_inCity$KS_VAL <- minmaxScale(KDE.short2_df_inCity$KS_VAL) 
  
  HotSpot.test$Long[((i-1)*Ngrids+1):(i*Ngrids)] <- KDE.long_df_inCity$KS_VAL
  HotSpot.test$Short1[((i-1)*Ngrids+1):(i*Ngrids)] <- KDE.short1_df_inCity$KS_VAL
  HotSpot.test$Short2[((i-1)*Ngrids+1):(i*Ngrids)] <- KDE.short2_df_inCity$KS_VAL
  
}  

# HS.test_class0 <- subset(subset(HotSpot.test,select=-c(Label3c.test)),Label2c.test==0)
# HS.test_class1 <- subset(subset(HotSpot.test,select=-c(Label3c.test)),Label2c.test==1)
# HS.test <- rbind(HS.test_class0,HS.test_class1)
```

```{r ROC, echo=FALSE, message=FALSE, warning=FALSE, fig.align='center',fig.width=6.5, fig.height=5.5, cache=TRUE}
library(ROCR)
# calculating the values for ROC curve
rocVal.test_lda <- prediction(Pred.test_lda$prob, TestDataLabel)
perf.test_lda <- performance(rocVal.test_lda, measure="tpr", x.measure="fpr")
auc.test_lda <- performance(rocVal.test_lda,"auc")
auc.test_lda <- unlist(slot(auc.test_lda, "y.values")) # convert S4 class to vector

rocVal.test_logit <- prediction(Pred.test_logit$prob, TestDataLabel)
perf.test_logit <- performance(rocVal.test_logit, measure="tpr", x.measure="fpr")
auc.test_logit <- performance(rocVal.test_logit,"auc")
auc.test_logit <- unlist(slot(auc.test_logit, "y.values")) # convert S4 class to vector

rocVal.test_hs_long <- prediction(HotSpot.test$Long, HotSpot.test$Label2c.test)
perf.test_hs_long <- performance(rocVal.test_hs_long, measure="tpr", x.measure="fpr")
auc.test_hs_long <- performance(rocVal.test_hs_long,"auc")
auc.test_hs_long <- unlist(slot(auc.test_hs_long, "y.values")) # convert S4 class to vector

rocVal.test_hs_short1 <- prediction(HotSpot.test$Short1, HotSpot.test$Label2c.test)
perf.test_hs_short1 <- performance(rocVal.test_hs_short1, measure="tpr", x.measure="fpr")
auc.test_hs_short1 <- performance(rocVal.test_hs_short1,"auc")
auc.test_hs_short1 <- unlist(slot(auc.test_hs_short1, "y.values")) # convert S4 class to vector

rocVal.test_hs_short2 <- prediction(HotSpot.test$Short2, HotSpot.test$Label2c.test)
perf.test_hs_short2 <- performance(rocVal.test_hs_short2, measure="tpr", x.measure="fpr")
auc.test_hs_short2 <- performance(rocVal.test_hs_short2,"auc")
auc.test_hs_short2 <- unlist(slot(auc.test_hs_short2, "y.values")) # convert S4 class to vector

par(mar=c(5,5,5,5),xaxs="i",yaxs="i",cex.axis=1,cex.lab=1)
plot(perf.test_lda,col="red",lty=1, lwd=2)
plot(perf.test_logit,col="green",lty=1, lwd=2,add=TRUE)
plot(perf.test_hs_long,col="blue",lty=1, lwd=2,add=TRUE)
plot(perf.test_hs_short1,col="yellow",lty=1, lwd=2,add=TRUE)
plot(perf.test_hs_short2,col="magenta",lty=1, lwd=2,add=TRUE)
mtext("ROC",side=3,cex=1,outer=TRUE)
# par(fig=c(0,1,0,1), oma=c(0,0,0,0), mar=c(0,0,0,0), new=TRUE)
par(new=TRUE)
plot(0, 0, type="n", bty="n", xaxt="n", yaxt="n",xlab="",ylab="")
legend("right",legend=c("LDA","logistic regression",paste0("long-term (", period.long,"-day) density"),paste0("short-term (", period.short1,"-day) density"),paste0("short-term (", period.short2,"-day) density")),col=c("red","green","blue","yellow","magenta"),lty=1, lwd=2,cex=0.8,inset = c(0,0),xpd=TRUE)
```

```{r AUC, echo=FALSE, message=FALSE, warning=FALSE, cache=TRUE}
library(knitr)
AUC <- data.frame(Model = c("LDA","Logistic Regression","Long-term Density","Short-term Density 1","Short-term Density 2"),
                        Testing = c(auc.test_lda,auc.test_logit,auc.test_hs_long,auc.test_hs_short1,auc.test_hs_short2))
kable(AUC,format="html",digits=2,caption="AUC")                       
```